#!/usr/bin/python3
import sys,re
import subprocess
import os
import stat
import tempfile
import pygit2
from time import time
from math import floor
from pprint import pprint

def git_clone(repo, dir, branch=None):
  cmd = ['git', 'clone']
  if branch != None:
    cmd += ['-b', branch]

  cmd += [repo, dir]

  rc = subprocess.call(cmd)
  if rc != 0:
    print('Failed ' + ' '.join(cmd))

def git_push(repo, remote, branch):
  cmd = ['git', '--git-dir={}/.git'.format(repo), 'push', remote, branch]

  rc = subprocess.call(cmd)
  if rc != 0:
    print('Failed ' + ' '.join(cmd))

def git_export(repo, branch, www):
  git = ['git', '--git-dir={}/.git'.format(repo), 'archive', branch]
  tar = ['tar', '-x', '-C', www]

  g = subprocess.Popen(git, stdout=subprocess.PIPE)
  t = subprocess.Popen(tar, stdin=g.stdout)
  g.stdout.close()
  rc = g.wait() + t.wait()
  if rc != 0:
    print('Failed ' + ' '.join(git) + ' | ' + ' '.join(tar))

def jekyll(source, target):
  cmd = ['jekyll', '--no-auto', source, '{}/_site'.format(target)]
  rc = subprocess.call(cmd)
  if rc != 0:
    print('Failed ' + ' '.join(cmd))

def empty_dir(path):
  names = []
  try:
    names = os.listdir(path)
  except os.error as e:
    return 1

  for name in names:
    fullname = os.path.join(path, name)
    try:
      mode = os.lstat(fullname).st_mode
    except os.error as e:
      mode = 0

    if stat.S_ISDIR(mode):
      empty_dir(fullname)
      os.rmdir(fullname)
    else:
      try:
        os.remove(fullname)
      except os.error as err:
        return 1

  return 0

def main():
  repo = os.path.realpath('.')
  for line in sys.stdin:
    print(line)
    m = re.search(r'^([0-9a-f]{40}) ([0-9a-f]{40}) refs/heads/([0-9a-zA-Z]+)$', line)
    if m:
      print("Processing {}".format(m.group(3)))
      branch = m.group(3)
      build_branch = 'build-{}'.format(branch)
      tmp_git = tempfile.TemporaryDirectory()
      tmp_git_master = '{}/{}'.format(tmp_git.name, branch)
      tmp_git_build  = '{}/build-{}'.format(tmp_git.name, branch)

      os.mkdir(tmp_git_master)
      os.mkdir(tmp_git_build)

      git_clone(repo, tmp_git_master, branch)
      git_clone(repo, tmp_git_build)

      master_repo = pygit2.Repository(tmp_git_master)
      build_repo  = pygit2.Repository(tmp_git_build)

      head =  build_repo.lookup_reference('HEAD')
      
      try:
        ref = build_repo.lookup_reference('refs/remotes/origin/{}'.format(build_branch))
        parents = [ref.oid]
      except KeyError as e:
        parents = []

      head.target = 'refs/heads/{}'.format(build_branch)
      pprint(parents)
      
      
      jekyll(tmp_git_master, tmp_git_build)

      build_index = build_repo.index

      for dirpath, dirnames, filenames in os.walk(tmp_git_build):
        m = re.search(r'\.git', dirpath)
        if m:
          continue
        for fn in filenames:
          build_index.add(os.path.relpath(os.path.join(dirpath, fn), tmp_git_build), 0)

      build_index.write()
      oid       = build_index.write_tree()
      tree      = build_repo[oid]
      author    = pygit2.Signature('jekyll', 'jekyll@alexchamberlain.co.uk', floor(time()), 0)
      committer = pygit2.Signature('git',       'git@alexchamberlain.co.uk', floor(time()), 0)
      build_repo.create_commit('refs/heads/{}'.format(build_branch), author, committer, "Build", tree.oid, parents)

      git_push(tmp_git_build, 'origin', build_branch)
      if 0 == empty_dir('/var/www/test'):
        git_export(tmp_git_build, build_branch, '/var/www/test')
    else:
      print("Ignoring {}".format(line))

if __name__=='__main__':
  main()
